<!DOCTYPE html>
<html lang="ru-ru"><head>
    <title>Сравнение в C#</title>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="description" content="Думаю, что каждый программист рано или поздно сталкивается с кодом, который работает «не так, как ты от него ожидаешь». Именно это и подтолкнуло меня к написанию следующей статьи, в которой я пытаюсь понять, почему Except в Linq работает так, как написан, а не так, как я хочу." />
    <meta property="og:type" content="article" />
    <meta property="og:image" content="https://alexandrv.ru/asserts/images/logo.jpg" />
    <meta property="og:url" content="https://alexandrv.ru/articles/comparer/" />
    <meta property="og:description" content="Думаю, что каждый программист рано или поздно сталкивается с кодом, который работает «не так, как ты от него ожидаешь». Именно это и подтолкнуло меня к написанию следующей статьи, в которой я пытаюсь понять, почему Except в Linq работает так, как написан, а не так, как я хочу." />
    <style>
@import "https://fonts.googleapis.com/css2?family=Inconsolata&display=swap";:root{--cursor-visibility:hidden}html,body{width:100%;height:100%;overflow:auto;font-family:inconsolata,monospace;font-size:4vmin;line-height:4.1vmin;font-weight:400}body{margin:0;display:flex;flex-direction:row;justify-content:center;align-items:center}#content{min-width:82vmin;min-height:82vmin}::-webkit-scrollbar{width:10px}::-webkit-scrollbar-track{border-radius:10px;box-shadow:inset 0 0 1px white}::-webkit-scrollbar-thumb{border-radius:10px;box-shadow:0 0 0 1px white}.cursor,#activity-title:after,#activity-content:after,#cd:after,#whoami:after,#cat:after,#tree:after{visibility:var(--cursor-visibility);content:"|";overflow:hidden;color:#fff;animation:blink 500ms linear infinite alternate}@keyframes blink{0%{opacity:0}100%{opacity:1}}@media only screen and (min-width:768px){body{font-size:2.5vmin;line-height:2.6vmin}#content{min-width:60vmin}}:root{--cursor-visibility:hidden}body{align-items:unset;overflow-y:scroll}#content{max-width:80vmin}pre{overflow-x:scroll;white-space:pre}@keyframes blink{0%{opacity:0}100%{opacity:1}}















    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
        
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    



body{background:#1b1d1e}body #terminal{color:#BBBBBB}body #user{color:#23E298}body #dir{color:#D08010}body .Typewriter__cursor{color:#BBBBBB}a{color:#BBBBBB}

        
.navFull {
    background-color: #353535;
    font-family: "Courier New";
    font-size: 17px;
    display: inline;
    position: fixed;
    bottom: 0px;
    left: 0px;
    width: 100%;
    padding-top: 5px;
    padding: 10px;
    padding-bottom: 0px;
}

.navCredits {
    float: right;
    padding-right: 18px;
    padding-bottom: 10px;
    padding-top: 5px;
}

#content::after {
    content: "\a\a";
    white-space: pre;
}
        
        
</style>



    <meta name="yandex-verification" content="355904de153d5134" />
    
    
    <script>window.yaContextCb = window.yaContextCb || []</script>
    <script src="https://yandex.ru/ads/system/context.js" async></script>

    <script type="text/javascript">
            (function (m, e, t, r, i, k, a) {
                m[i] = m[i] || function () { (m[i].a = m[i].a || []).push(arguments) };
                m[i].l = 1 * new Date();
                for (var j = 0; j < document.scripts.length; j++) { if (document.scripts[j].src === r) { return; } }
                k = e.createElement(t), a = e.getElementsByTagName(t)[0], k.async = 1, k.src = r, a.parentNode.insertBefore(k, a)
            })
            (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

        ym(90533415, "init", {
            clickmap: true,
            trackLinks: true,
            accurateTrackBounce: true
        });
    </script>
    <noscript>
        <div><img src="https://mc.yandex.ru/watch/90533415" style="position:absolute; left:-9999px;" alt="" /></div>
    </noscript>
    


</head><body><div id="content">
<div id="block">

    <div id="yandex_rtb_R-A-1957258-2"></div>
    <script>window.yaContextCb.push(() => {
            Ya.Context.AdvManager.render({
                renderTo: 'yandex_rtb_R-A-1957258-2',
                blockId: 'R-A-1957258-2'
            })
        })</script>
</div>
<meta property="og:title" content="Сравнение в C#"/>


    
    
    



    


    <span id='terminal'><h1 id='title'>Сравнение в C#</h1><span id='date'>2021-11-20 17:23:23 +0300 MSK</span></span>

    <span id=''><h2 id="предисловие">Предисловие</h2>
<p>Автор знает, как работает сравнение в C#, достаточно четко представляет разницу между семантикой значимого и ссылочного типов, однако все еще находит эту статью хорошей и позволяющей чуть глубже заглянуть под капот.</p>
<hr>
<p>Думаю, что каждый программист рано или поздно сталкивается с кодом, который работает «не так, как ты от него ожидаешь». Именно это и подтолкнуло меня к написанию следующей статьи, в которой я пытаюсь понять, почему Except в Linq работает так, как написан, а не так, как я хочу.</p>
<hr>
<p>Что, по вашему мнению, должен вывести следующий код:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">var</span> documentsDir = <span style="color:#66d9ef">new</span> DirectoryInfo(Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments));

FileInfo[] FirstDirrectoryFiles = documentsDir.GetFiles();
FileInfo[] SecondDirrectoryFiles = documentsDir.GetFiles();
<span style="color:#66d9ef">foreach</span> (FileInfo item <span style="color:#66d9ef">in</span> FirstDirrectoryFiles.Except(SecondDirrectoryFiles))
{
    Console.WriteLine(item.Name);
}
</code></pre></div><p>Я вот предположил, что ничего, потому что Except должен вычитать множество (IEnumerable) правого аргумента из множества (IEnumerable) левого аргумента. Однако, вопреки моим ожиданиям я получил:</p>
<p><img src="/asserts/images/comparer_1.png" alt=""></p>
<p>Вне всякого сомнения — это не похоже на пустое множество. Давайте попробуем разобраться в том, почему так получается (результат в .NET 5 и в .NET 6 — эквивалентен). Чтобы понять, почему так происходит, и что можно с этим сделать обратимся к документации метода <a href="https://docs.microsoft.com/ru-ru/dotnet/api/system.linq.enumerable.except?view=net-6.0">Except</a>. Там действительно написано, что этот метод «Находит разность множеств, представленных двумя последовательностями» и имеет две перегрузки:</p>
<ul>
<li><code>Except&lt;TSource&gt;(IEnumerable&lt;TSource&gt;, IEnumerable&lt;TSource&gt;)</code> Находит разность множеств, представленных двумя последовательностями, используя для сравнения значений компаратор проверки на равенство по умолчанию.</li>
<li><code>Except&lt;TSource&gt;(IEnumerable&lt;TSource&gt;, IEnumerable&lt;TSource&gt;, IEqualityComparer&lt;TSource&gt;)</code>. Находит разность множеств, представленных двумя последовательностями, используя для сравнения значений указанный компаратор IEqualityComparer<!-- raw HTML omitted -->.</li>
</ul>
<p>Обратите внимание на заявление о том, что для сравнения используется компаратор по умолчанию. Чтобы понять, почему наш код сработал именно так, как сработал, нам предстоит разобраться с поведением компаратора по умолчанию. Для этого я предлагаю проследовать на <a href="https://github.com/dotnet/runtime/">https://github.com/dotnet/runtime/</a> и проанализировать работу метода Except.</p>
<p>Наша <a href="https://github.com/dotnet/runtime/blob/a7c69745a4e22757c69f65d2a750e2d6923e1186/src/libraries/System.Linq/src/System/Linq/Except.cs#L10">точка входа</a>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> IEnumerable&lt;TSource&gt; Except&lt;TSource&gt;(<span style="color:#66d9ef">this</span> IEnumerable&lt;TSource&gt; first, IEnumerable&lt;TSource&gt; second)
{
    <span style="color:#66d9ef">if</span> (first == <span style="color:#66d9ef">null</span>)
    {
        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.first);
    }

    <span style="color:#66d9ef">if</span> (second == <span style="color:#66d9ef">null</span>)
    {
        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.second);
    }

    <span style="color:#66d9ef">return</span> ExceptIterator(first, second, <span style="color:#66d9ef">null</span>);
}
</code></pre></div><p>Метод проверяет, что получил два объекта с ненулевым указателем и передает аргументы в <a href="https://github.com/dotnet/runtime/blob/a7c69745a4e22757c69f65d2a750e2d6923e1186/src/libraries/System.Linq/src/System/Linq/Except.cs#L79">ExceptIterator</a>.</p>
<p>Строго говоря, можно было бы использовать и метод перегрузку, так как он работает буквально также:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> IEnumerable&lt;TSource&gt; Except&lt;TSource&gt;(<span style="color:#66d9ef">this</span> IEnumerable&lt;TSource&gt; first, IEnumerable&lt;TSource&gt; second, IEqualityComparer&lt;TSource&gt;? comparer)
{
    <span style="color:#66d9ef">if</span> (first == <span style="color:#66d9ef">null</span>)
    {
        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.first);
    }

    <span style="color:#66d9ef">if</span> (second == <span style="color:#66d9ef">null</span>)
    {
        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.second);
    }

    <span style="color:#66d9ef">return</span> ExceptIterator(first, second, comparer);
}
</code></pre></div><p>Почему перегрузка, а не параметр по умолчанию? Силами <a href="https://t.me/dotnettalks">сообщества</a> было вынесено предположение, что дело в <a href="https://coding.abel.nu/2014/07/adding-an-overload-is-a-breaking-change/">этом</a> и <a href="https://rules.sonarsource.com/csharp/RSPEC-2360">этом</a>.</p>
<p>Собственно код <a href="https://github.com/dotnet/runtime/blob/a7c69745a4e22757c69f65d2a750e2d6923e1186/src/libraries/System.Linq/src/System/Linq/Except.cs#L79">ExceptIterator</a>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> IEnumerable&lt;TSource&gt; ExceptIterator&lt;TSource&gt;(IEnumerable&lt;TSource&gt; first, IEnumerable&lt;TSource&gt; second, IEqualityComparer&lt;TSource&gt;? comparer)
{
    <span style="color:#66d9ef">var</span> <span style="color:#66d9ef">set</span> = <span style="color:#66d9ef">new</span> HashSet&lt;TSource&gt;(second, comparer);

    <span style="color:#66d9ef">foreach</span> (TSource element <span style="color:#66d9ef">in</span> first)
    {
        <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">set</span>.Add(element))
        {
            <span style="color:#66d9ef">yield</span> <span style="color:#66d9ef">return</span> element;
        }
    }
}

</code></pre></div><p>Из элементов второго аргумента создается <a href="https://github.com/dotnet/runtime/blob/57bfe474518ab5b7cfe6bf7424a79ce3af9d6657/src/libraries/System.Private.CoreLib/src/System/Collections/Generic/HashSet.cs#L55">множество</a>. Элементы первого аргумента, которые удалось добавить в множество, возвращаются в качестве итератора.</p>
<p>Конструктор множества принимает интерфейс компаратора, который используется для сравнения элементов множества:</p>
<p><img src="/asserts/images/comparer_2.png" alt=""></p>
<p>Конкретно в нашем случае компаратор равен null, поэтому проваливаемся в свойство Default обобщенного класса EqualityComparer.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">public</span> HashSet(IEqualityComparer&lt;T&gt;? comparer)
{
    <span style="color:#66d9ef">if</span> (comparer <span style="color:#66d9ef">is</span> not <span style="color:#66d9ef">null</span> &amp;&amp; comparer != EqualityComparer&lt;T&gt;.Default) <span style="color:#75715e">// first check for null to avoid forcing default comparer instantiation unnecessarily
</span><span style="color:#75715e"></span>    {
        <span style="color:#ae81ff">_</span>comparer = comparer;
    }

    <span style="color:#75715e">// Special-case EqualityComparer&lt;string&gt;.Default, StringComparer.Ordinal, and StringComparer.OrdinalIgnoreCase.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// We use a non-randomized comparer for improved perf, falling back to a randomized comparer if the
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// hash buckets become unbalanced.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">typeof</span>(T) == <span style="color:#66d9ef">typeof</span>(<span style="color:#66d9ef">string</span>))
    {
        IEqualityComparer&lt;<span style="color:#66d9ef">string</span>&gt;? stringComparer = NonRandomizedStringEqualityComparer.GetStringComparer(<span style="color:#ae81ff">_</span>comparer);
        <span style="color:#66d9ef">if</span> (stringComparer <span style="color:#66d9ef">is</span> not <span style="color:#66d9ef">null</span>)
        {
            <span style="color:#ae81ff">_</span>comparer = (IEqualityComparer&lt;T&gt;?)stringComparer;
        }
    }
}
</code></pre></div><p><img src="/asserts/images/comparer_3.png" alt=""></p>
<p><a href="https://github.com/dotnet/runtime/blob/57bfe474518ab5b7cfe6bf7424a79ce3af9d6657/src/coreclr/System.Private.CoreLib/src/System/Collections/Generic/EqualityComparer.CoreCLR.cs#L10">Тут</a>, на мой скромный взгляд, все очевидно:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">partial</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">EqualityComparer</span>&lt;T&gt; : IEqualityComparer, IEqualityComparer&lt;T&gt;
{
    <span style="color:#75715e">// To minimize generic instantiation overhead of creating the comparer per type, we keep the generic portion of the code as small
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// as possible and define most of the creation logic in a non-generic class.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> EqualityComparer&lt;T&gt; Default { [Intrinsic] <span style="color:#66d9ef">get</span>; } = (EqualityComparer&lt;T&gt;)ComparerHelpers.CreateDefaultEqualityComparer(<span style="color:#66d9ef">typeof</span>(T));
}

</code></pre></div><p>Комментарий гласит, что с целью минимизации накладных расходов на создание универсального экземпляра для каждого типа код обобщенных классов уменьшают насколько это возможно за счет переноса его логики в необобщенный класс (в нашем случае это ComparerHelpers).</p>
<p>Давайте же посмотрим на то, как <a href="https://github.com/dotnet/runtime/blob/57bfe474518ab5b7cfe6bf7424a79ce3af9d6657/src/coreclr/System.Private.CoreLib/src/System/Collections/Generic/ComparerHelpers.cs#L116">происходит процесс создания компаратора по умолчанию</a>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">internal</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">object</span> CreateDefaultEqualityComparer(Type type)
{
    Debug.Assert(type != <span style="color:#66d9ef">null</span> &amp;&amp; type <span style="color:#66d9ef">is</span> RuntimeType);

    <span style="color:#66d9ef">object?</span> result = <span style="color:#66d9ef">null</span>;
    <span style="color:#66d9ef">var</span> runtimeType = (RuntimeType)type;

    <span style="color:#66d9ef">if</span> (type == <span style="color:#66d9ef">typeof</span>(<span style="color:#66d9ef">byte</span>))
    {
        <span style="color:#75715e">// Specialize for byte so Array.IndexOf is faster.
</span><span style="color:#75715e"></span>        result = <span style="color:#66d9ef">new</span> ByteEqualityComparer();
    }
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (type == <span style="color:#66d9ef">typeof</span>(<span style="color:#66d9ef">string</span>))
    {
        <span style="color:#75715e">// Specialize for string, as EqualityComparer&lt;string&gt;.Default is on the startup path
</span><span style="color:#75715e"></span>        result = <span style="color:#66d9ef">new</span> GenericEqualityComparer&lt;<span style="color:#66d9ef">string</span>&gt;();
    }
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (type.IsAssignableTo(<span style="color:#66d9ef">typeof</span>(IEquatable&lt;&gt;).MakeGenericType(type)))
    {
        <span style="color:#75715e">// If T implements IEquatable&lt;T&gt; return a GenericEqualityComparer&lt;T&gt;
</span><span style="color:#75715e"></span>        result = CreateInstanceForAnotherGenericParameter((RuntimeType)<span style="color:#66d9ef">typeof</span>(GenericEqualityComparer&lt;<span style="color:#66d9ef">string</span>&gt;), runtimeType);
    }
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (type.IsGenericType)
    {
        <span style="color:#75715e">// Nullable does not implement IEquatable&lt;T?&gt; directly because that would add an extra interface call per comparison.
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// Instead, it relies on EqualityComparer&lt;T?&gt;.Default to specialize for nullables and do the lifted comparisons if T implements IEquatable.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (type.GetGenericTypeDefinition() == <span style="color:#66d9ef">typeof</span>(Nullable&lt;&gt;))
        {
            result = TryCreateNullableEqualityComparer(runtimeType);
        }
    }
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (type.IsEnum)
    {
        <span style="color:#75715e">// The equality comparer for enums is specialized to avoid boxing.
</span><span style="color:#75715e"></span>        result = TryCreateEnumEqualityComparer(runtimeType);
    }

    <span style="color:#66d9ef">return</span> result ?? CreateInstanceForAnotherGenericParameter((RuntimeType)<span style="color:#66d9ef">typeof</span>(ObjectEqualityComparer&lt;<span style="color:#66d9ef">object</span>&gt;), runtimeType);
}
</code></pre></div><p>Пойдем по порядку:</p>
<ol>
<li>
<p>Если тип аргумента byte, то возвращается компаратор специально для этого типа (ByteEqualityComparer)</p>
</li>
<li>
<p>Если это строка, то возвращается GenericEqualityComparer<!-- raw HTML omitted -->();</p>
</li>
<li>
<p>Если тип реализует IEquatable, то на основе GenericEqualityComparer<!-- raw HTML omitted --> возвращается GenericEqualityComparer для типа аргумента (даже не спрашивайте);</p>
</li>
<li>
<p>Если аргумент является универсальным типом (обобщением) и если этот универсальный тип Nullable&lt;&gt;,  <a href="https://github.com/dotnet/runtime/blob/57bfe474518ab5b7cfe6bf7424a79ce3af9d6657/src/coreclr/System.Private.CoreLib/src/System/Collections/Generic/ComparerHelpers.cs#L160">то на основе</a> NullableEqualityComparer<!-- raw HTML omitted -->  создается NullableEqualityComparer для типа аргумента;</p>
</li>
<li>
<p>Если аргумент – перечисление, <a href="https://github.com/dotnet/runtime/blob/57bfe474518ab5b7cfe6bf7424a79ce3af9d6657/src/coreclr/System.Private.CoreLib/src/System/Collections/Generic/ComparerHelpers.cs#L179">то на основе</a> EnumEqualityComparer&lt;&gt; создается EnumEqualityComparer;</p>
</li>
<li>
<p>Во всех остальных случаях на основе ObjectEqualityComparer<!-- raw HTML omitted --> создается ObjectEqualityComparer.</p>
</li>
</ol>
<p>С помощью такого нехитрого кода (хотел было переписать через string builder, но, думаю, тут можно забить :D) попробуем понять, какой же из перечисленных случаев – наш:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">var</span> documentsDir = <span style="color:#66d9ef">new</span> DirectoryInfo(Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments));
FileInfo[] result1 = documentsDir.GetFiles();
FileInfo[] result2 = documentsDir.GetFiles();

Type type = result1[<span style="color:#ae81ff">0</span>].GetType();
Console.Write(
    <span style="color:#e6db74">$&#34;type == typeof(byte): {type == typeof(byte)}\n&#34;</span> +
    <span style="color:#e6db74">$&#34;type == typeof(string): {type == typeof(string)}\n&#34;</span> +
    <span style="color:#e6db74">$&#34;type.IsAssignableTo(typeof(IEquatable&lt;&gt;).MakeGenericType(type)): {type.IsAssignableTo(typeof(IEquatable&lt;&gt;).MakeGenericType(type))}\n&#34;</span> +
    <span style="color:#e6db74">$&#34;type.IsGenericType: {type.IsGenericType}\n&#34;</span> +
    <span style="color:#e6db74">$&#34;type.IsEnum: {type.IsEnum}\n\n&#34;</span>);
</code></pre></div><p>Что и следовало ожидать:</p>
<p><img src="/asserts/images/comparer_4.png" alt=""></p>
<p>Это значит, что теперь наш путь лежит в <a href="https://github.com/dotnet/runtime/blob/57bfe474518ab5b7cfe6bf7424a79ce3af9d6657/src/libraries/System.Private.CoreLib/src/System/Collections/Generic/EqualityComparer.cs">ObjectEqualityComparer</a>. Вот, собственно, и он:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">sealed</span> <span style="color:#66d9ef">partial</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ObjectEqualityComparer</span>&lt;T&gt; : EqualityComparer&lt;T&gt;
{
<span style="color:#a6e22e">    [MethodImpl(MethodImplOptions.AggressiveInlining)]</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">bool</span> Equals(T? x, T? y)
    {
        <span style="color:#66d9ef">if</span> (x != <span style="color:#66d9ef">null</span>)
        {
            <span style="color:#66d9ef">if</span> (y != <span style="color:#66d9ef">null</span>) <span style="color:#66d9ef">return</span> x.Equals(y);
            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
        }
        <span style="color:#66d9ef">if</span> (y != <span style="color:#66d9ef">null</span>) <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>;
    }
<span style="color:#a6e22e">
</span><span style="color:#a6e22e">    [MethodImpl(MethodImplOptions.AggressiveInlining)]</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">int</span> GetHashCode([DisallowNull] T obj) =&gt; obj?.GetHashCode() ?? <span style="color:#ae81ff">0</span>;

    <span style="color:#75715e">// Equals method for the comparer itself.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">bool</span> Equals([NotNullWhen(<span style="color:#66d9ef">true</span>)] <span style="color:#66d9ef">object?</span> obj) =&gt;
        obj != <span style="color:#66d9ef">null</span> &amp;&amp; GetType() == obj.GetType();

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">int</span> GetHashCode() =&gt;
        GetType().GetHashCode();
}

</code></pre></div><p>ObjectEqualityComparer определяет метод Equals для двух объектов следующим образом:</p>
<ul>
<li>
<p>Объекты равны, если они оба null (что логично);</p>
</li>
<li>
<p>Объекты не равны, если только один из них null;</p>
</li>
<li>
<p>Если оба объекта не null, то их эквивалентность определяется методом Equals «левого» аргумента.</p>
</li>
</ul>
<p>Если обратиться к <a href="https://docs.microsoft.com/ru-ru/dotnet/api/system.io.fileinfo?view=net-6.0#methods">документации</a>, то можно увидеть, что у нашего класса FileInfo действительно есть метод Equals с пометкой «Унаследовано от Object». Что же, <a href="https://docs.microsoft.com/ru-ru/dotnet/api/system.object.equals?view=net-6.0#System_Object_Equals_System_Object_">туда</a> и лежит наш путь! Там в секции «комментарии» мы можем узнать, что:</p>
<blockquote>
<p>Если текущий экземпляр является ссылочным типом, Equals(Object) метод проверяет равенство ссылок, а вызов Equals(Object) метода эквивалентен вызову ReferenceEquals метода. Равенство ссылок означает, что сравниваемые объектные переменные ссылаются на один и тот же объект.</p>
</blockquote>
<p>На этом, казалось, можно было бы завершить наше путешествие, но давайте на последок придумаем, как заставить Except перестать показывать файлы в директории с моими документами.</p>
<p>Вариант из категории «пока так, потом пофикшу»:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">var</span> documentsDir = <span style="color:#66d9ef">new</span> DirectoryInfo(Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments));
FileInfo[] result1 = documentsDir.GetFiles();
FileInfo[] result2 = documentsDir.GetFiles();
<span style="color:#66d9ef">foreach</span> (FileInfo item <span style="color:#66d9ef">in</span> result1
                                 .Select(i =&gt; i.FullName)
                                 .Except(result2.Select(i =&gt; i.FullName))
                                 .Select(i =&gt; <span style="color:#66d9ef">new</span> FileInfo(i)))
{
    Console.WriteLine(item.Name);
}

</code></pre></div><p>Мы, по сути, вызываем Except для двух IEnumerate<!-- raw HTML omitted -->, а потом из результата снова собираем IEnumerate<!-- raw HTML omitted -->.</p>
<p>В свежем .net6 еще можно воспользоваться <a href="https://docs.microsoft.com/en-us/dotnet/api/system.linq.enumerable.exceptby?view=net-6.0">ExceptBy</a>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">var</span> documentsDir = <span style="color:#66d9ef">new</span> DirectoryInfo(Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments));
FileInfo[] result1 = documentsDir.GetFiles();
FileInfo[] result2 = documentsDir.GetFiles();
<span style="color:#66d9ef">foreach</span> (FileInfo item <span style="color:#66d9ef">in</span> result1.ExceptBy(result2.Select(i =&gt; i.FullName), ks =&gt; ks.FullName))
{
    Console.WriteLine(item.Name);
}
</code></pre></div><p>Этот код уже выглядит приятнее и даже избавляет нас от необходимости разбирать и снова собирать изначальный массив, но можно сделать это иначе.</p>
<p>Следующей идеей, посетившей мою голову, было унаследовать FileInfo и переопределить Equals, но, к сожалению, FileInfo является запечатанным (sealed) классом, а это значит, что он не может быть унаследован, так что этот путь нам отрезан.</p>
<p>Подойдем к вопросу с другой стороны. Вспомним, что Equals имеет перегрузку, принимающую вторым аргументом IEqualityComparer, что позволяет нам создать что-то вроде такого решения:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">var</span> documentsDir = <span style="color:#66d9ef">new</span> DirectoryInfo(Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments));
FileInfo[] result1 = documentsDir.GetFiles();
FileInfo[] result2 = documentsDir.GetFiles();

<span style="color:#66d9ef">foreach</span> (FileInfo item <span style="color:#66d9ef">in</span> result1.Except(result2, <span style="color:#66d9ef">new</span> CustomFileInfoComparer()))
{
    Console.WriteLine(item.Name);
}

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CustomFileInfoComparer</span> : IEqualityComparer&lt;FileInfo&gt;
{
    <span style="color:#66d9ef">bool</span> IEqualityComparer&lt;FileInfo&gt;.Equals(FileInfo? lhv, FileInfo? rhv)
       =&gt; lhv?.FullName == rhv?.FullName;
    <span style="color:#66d9ef">int</span> IEqualityComparer&lt;FileInfo&gt;.GetHashCode(FileInfo obj) =&gt; obj.FullName.GetHashCode();
}

</code></pre></div><p>Это решение хорошо подходит в том случае, если дальше по коду вам предстоит еще хотя бы раз сравнивать IEnumerable<!-- raw HTML omitted -->.</p>
<p>На этом у меня все, надеюсь, что читатель нашел любопытным мой скромный труд.</p>
<p>Хочется выразить огромную благодарность моей жене за помощь в подготовке данного поста, а также сообществу <a href="https://t.me/dotnettalks">.NET Talks🎄</a></p>
</span>



    </div>
    <style>
    h1 {
         
        color: #23E298;
        line-height: 6vmin;
        font-size: 6vmin;
    }

    
    #block {
        max-height: 200px;
    }
    ul ::marker {
        
        content: "-rw-rw-r--";

    }

    a, strong, ::marker,
    #date {
        color: #D08010;

    }
    table, td{
        border-collapse: collapse;
        border: 2px solid #D08010;
        max-width: 100%;
    }
    td{
        padding: 25px;
    }
    li a {
        font-family: -apple-system, BlinkMacSystemFont, Arial, sans-serif;
        font-size: 0.5rem;
        line-height: 1.56;
    }

    li {
        padding-left: 2%;


    }
    a{
        text-decoration: none;
    }
    img{
        max-width: 100%;
    }
    #content {
        font-size: 0.5rem;
        line-height: 1.56;
        overflow-wrap: break-word;
        font-family: -apple-system, BlinkMacSystemFont, Arial, sans-serif;
    }
    #content{
        color:#BBBBBB;
    }
</style>


    
    <span class="navFull">
        
    
    

    
        

<span>
    <a href="/">Home</a>
    <span>&#8192;|&#8192;</span>
    <a href="./..">/articles/</a>
</span>

    

        
        <span class="navCredits">
            Hugo theme created by
            <a href="https://github.com/Yukuro/hugo-theme-shell" target="_blank" rel="noopener">Yukuro</a>
        </span>
</span>


    

    

</body>

</html>